### 学习笔记O(∩_∩)O
#### 倍增
> 倍增是一种思想。依据这种思想，衍生出了ST表、LCA(最近公共祖先)以及一些在树上的倍增应用。

考虑这样一个问题：如何快速在一个序列s中查询到不大于a的值？（这里序列已排序好
正常思想就是二分，每次取得s中`l,r,mid`的值，进行比较后快速logn速度逼近正确的值。但是这里我们不考虑二分
倍增和二分的思想很类似。对于一个单调的序列，我们可以快速的跳过太小的（或者太大的）数，从而快速逼近结果。
简单的模拟一下倍增：
・ 设置一个长度p，每次如果查询到的值小于**目标**，位置`k+=p`，长度`p=2*p`
・ 如果查询到的值大于**目标**，长度`p=p/2`。并重复上一个步骤。
・ 循环查询到确切的目标。
比如，起初位置在k为0，p为2.查询到s[k+p]为小于**目标**的数，`k`就变成了`k+p`，`p`增倍了。下一次查询到s[k+p]大于了**目标**数，我们就把p先减小为一半。再查一次。如果有概念了，可以想象出平均下来是logn的。

#### ST表

> st表灵活的使用了倍增的思想
> 可以进行对区间最值问题的快速查找与更新
> 预处理O（n・logn），查询O（1），空间（n・logn）

线段树虽说是区间维护的全能王，但是也恰巧这样导致了他在一些特别的方面处理比较慢，线段树的查询是O(logn)的，而且占用的空间也较大，所以容易被卡常数。

#### 字典树 Trie
> 将所有字符串依据前缀构建的一棵树
> 其中的节点表示字符串的某个字符，树的根是一个空指针
> 是一种存放字符串的数据结构（就是为了其他算法的使用专门设计的

#### AC自动机
（好像顺序乱套了
> 不是可以自动Acepte的程序
> 是基于kmp思想，建立在字典树上的自动匹配字符串算法
> 多个模板串，一个目标串
> `重要词典:`
> 失败指针(fail指针)：指的是在匹配某个字符串的时候，如果到当前的位置发现不匹配，会跳到某个其他前缀匹配的位置，继续匹配。如果仍然没有，就会跳回到根

#### 佩尔方程
（没想到还是要学数论
> 满足：x^2 - d*y^2 = 1 的方程
> 方程通过假设x1,x2两个解，解出了另一个新的解。这代表了如果知道方程中的最小特解，就能推论出所有的解。
> 通解：`Xn = Xn-1 * X1 + d * Yn-1 * Y1`   `Yn = Xn-1 * X1 + Yn-1 * Y1`
> 半难以发现正解公式，需要通过自己一步一步推公式。

#### 赛后笔记
> 先贪心再暴力
> 打表找规律推公式
> 关于long long 要先仔细读题思考哪些部分需要再修改部分
> 
